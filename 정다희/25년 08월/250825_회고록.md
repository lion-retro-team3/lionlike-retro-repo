### 오늘 배운 내용 중 가장 기억에 남는 것
#### 1. super와 super()
- `super` : 부모 클래스의 멤버에 접근  
- `super()`: 부모 클래스의 생성자에 접근

```java
class Parent {
    String name;

    // 부모 생성자
    Parent(String name) {
        this.name = name;
        System.out.println("Parent 생성자 호출: " + name);
    }

    void hello() {
        System.out.println("안녕, 나는 Parent!");
    }
}

class Child extends Parent {
    int age;

    // 자식 생성자
    Child(String name, int age) {
        super(name); // ✅ 부모 생성자 호출 (반드시 첫 줄)
        this.age = age;
        System.out.println("Child 생성자 호출: " + name + ", " + age);
    }

    @Override
    void hello() {
        super.hello(); // ✅ 부모 메서드 호출
        System.out.println("안녕, 나는 Child! 나이는 " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        Child c = new Child("홍길동", 20);
        c.hello();
    }
}
```

#### 2. Getter / Setter
- Getter / Setter는 자바에서 캡슐화(Encapsulation)를 지키기 위해 가장 많이 쓰이는 패턴

```java
class Person {
    // 필드는 private으로 감춤 (외부에서 직접 접근 불가)
    private String name;
    private int age;

    // Getter (읽기)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Setter (쓰기)
    public void setName(String name) {
        // 유효성 검사 추가 가능
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("이름은 비어 있을 수 없습니다.");
        }
        this.name = name;
    }

    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
        }
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();

        // setter로 값 설정
        p.setName("홍길동");
        p.setAge(20);

        // getter로 값 조회
        System.out.println("이름: " + p.getName());
        System.out.println("나이: " + p.getAge());
    }
}
```

필드에 직접 접근하지 않고 굳이 Getter/Setter를 쓰는 이유?
1. 캡슐화: 필드를 `private`로 감추고 `public 메서드를 통해서만 접근 가능하게 하여 외부에서 직접 값을 바꿔버리는 것을 방지.
2. 데이터 무결성 보장: setter안에 나이가 음수가 되지 않도록 하는등의 유효성 검사를 넣을 수 있음.
3. 내부 구현 변경의 유연성: 필드 타입이나 저장 방식이 바뀌어도 외부 코드는 그대로 사용 가능.
4. 읽기 전용 / 쓰기 전용 제어 가능 : `getter`만 만들면 읽기 전용, `setter`만 만들면 쓰기 전용

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것

#### 상속관계에서의 생성자
1. 두 클래스가 상속 관계로 묶여 있다면, 자식 클래스의 생성자 첫 줄엔 반드시 부모 클래스 생성자를 호출 해야 한다.
2. 부모 클래스의 생성자가 명시되어 있지 않으면 매개변수가 없는 생성자가 생략되어 있으므로, 자식 클래스의 생성자도 생략 가능하다.
3. 부모 클래스에서 매개변수가 있는 생성자가 있다면 자식 클래스 생성자에서 반드시 첫 줄에 명시 해주어야 한다.
4. 모든 생성자가 실행 되고 난 후, 메서드가 실행 된다.
5. 상속관계에 있지 않다면 객체가 생성되어야 생성자가 실행되지만, 상속 관계에서는 자식클래스가 실행되면 부모의 생성자도 무조건 실행된다.

```java
class Parent {
    String name;

    // Parent 생성자
    Parent(String name) {
        this.name = name;
        System.out.println("Parent 생성자 호출: " + name);
    }

    void hello() {
        System.out.println("안녕, 나는 Parent!");
    }
}

class Child extends Parent {
    int age;

    // Child 생성자
    Child(String name, int age) {
        super(name); // 부모 생성자 호출 (반드시 첫 줄)
        this.age = age;
        System.out.println("Child 생성자 호출: " + name + ", " + age);
    }

    @Override
    void hello() {
        super.hello(); // 부모 메서드 호출
        System.out.println("안녕, 나는 Child! 나이는 " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        Child c = new Child("홍길동", 20); 
        c.hello();
    }
}
```
실행결과
```java
Parent 생성자 호출: 홍길동
Child 생성자 호출: 홍길동, 20
안녕, 나는 Parent!
안녕, 나는 Child! 나이는 20
```

#### 필드는 타입을 따른다
상속 관계에서 메서드와 필드 동작 차이를 설명할 때 자주 쓰는 표현이다.

- 메서드: 오버라이딩이 되면 실제 객체 타입 기준으로 실행 -> "메서드는 객체 타입을 따른다."
- 필드: 오버라이딩(재정의)이 없고, 참조 변수 타입 기준으로 접근 -> "필드는 참조 타입을 따른다."

이게 처음에 이해가 안됐었는데 이해가 안될땐 코드 예제를 보는게 가장 빠르다.

```java
class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";
}

public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.name); // Parent
        System.out.println(c.name); // Child
    }
}
```
위의 코드를 보면 `p`가 실제로 `new Child()`객체를 가리키고 있어도, 필드 참조는 참조 변수 타입에 따라 **정적 바인딩** 된다.

```java
class Parent {
    void printName() { System.out.println("Parent"); }
}

class Child extends Parent {
    @Override
    void printName() { System.out.println("Child"); }
}

public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        p.printName(); // Child (메서드는 객체 타입을 따른다)
    }
}
```

반면에 메서드는 **동적 디스패치** 덕분에 실제 객체 기준(Child)으로 실행된다.


***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

- [블로그에 작성한 TIL](https://velog.io/@daheenamic/멋쟁이사자처럼TIL-Java-상속)

```text
오늘은 정신없는 월요일이었다. 본격적으로 객체지향 심화 수업을 들어가며 상속으로 시작을 했다.
처음에는 extends 키워드 하나로 상속받고 부모 클래스의 필드를 가져다 쓰고, 메서드를 가져다 쓰고
여기까지는 이해가 잘 되다가 생성자 들어가면서 또 헷갈리기 시작했다.
상속 부분에서 많은 설명이 필요하고, 오늘 비디오나 마이크 환경도 좋지 않아서
회고시간에 7명이 돌아가며 발표할 내용이 많이 않아서 각자의 회고 시간을 갖기로 했다.
아무튼 오늘은 수업이 끝나고 개념 정리 다시 한 번하고 자바의 정석을 보든 인강을 보든 다시 깊게 살펴봐야겠다.
```

